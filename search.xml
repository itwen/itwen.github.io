<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序开发过程中踩坑记--（环境配置篇）]]></title>
    <url>%2F2017%2F07%2F30%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B8%A9%E5%9D%91%E8%AE%B0--(%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[小程序开发过程中踩坑记—（环境配置篇）1、前期准备工作开发小程序需要准备一下东西 1.1）服务器（不需要网络请求的可以不用） 1.2）域名 1.3）ssl证书，小程序规定所有请求必须走HTTPS 1.1服务器准备1.1 服务器基础信息第一次比较正式的写前端和后端的东西 过程中碰到很多坑，这里我把一些东西总结出来，避免不熟悉的人踩同样的坑 我这里使用的是亚马逊的云主机，从注册起可免费使用一年，每个月750个小时的实例运行时间，如果只创建一个实例 一个月750个小时完全是够用的，使劲戳这里去创建一个 下面我的云主机的一些配置 CPU信息 看起来好像还不错的样子 淘宝搜了下 e5-2676 v3 也要两三千 内存信息 这个有点寒掺了 只有一个g 不过个人练手项目够用了 硬盘大小 只有十个g大小 可用的不到8g 所以我的小程序需要上传的一些文件图片的什么的 我都转存到七牛上面 戳我去注册一个 但是免费的容量和流量都有限 1.2服务器的环境搭建通过ssh连接到云主机 这里我服务端使用的开发语言是Java 数据使用的是MySQL ，开发框架最常见的springMVC+mybatis mysql 安装，这里亚马逊的云主机是自带了jdk的 如果没有需要自己去安装, sudo yum install mysql mysql-server mysql-devel -y 最后提示 Complete! 表示安装成功 查看是否生成了mysqld服务, 并设置随机启动 chkconfig --list |grep mysql 设置MySQL开机启动 sudo chkconfig mysqld on 启动MySQL服务 sudo service mysqld start 显示OK代表启动成功 链接数据库,默认是没有密码 mysql -u root -p 可以设置密码，需要退出数据库连接 mysqladmin -u root password XXXXX 设置数据库是否可以远程链接 GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION; 第一个星号代表可以允许那个数据库对外链接 第二个星号代表可以允许这个数据库里面的哪张表可以 root 表示以root 用户登录 % 表示可以允许来自任一IP的主机链接 123456 表示密码 在日常开发中为了保证规范，一般都是有三套开发环境，日常开发环境，预发测试环境，线上正式环境，这样才可以保证日常开发不会影响线上的运行，不同的环境部署到不同的机器，但是这里我们乞丐版个人只有一个机器，这里我就教大家一个如何使用一个一台机器配置多套运行环境。 首先我先链接好数据库后 创建两个数据库 create database release; //线上正式环境 create database prerelease //预发测试环境 。线下环境 就是自己本地的机器 创建好了两个数据库后，两个数据库建立一模一样的表。然后就是下载Tomcat 这里就不赘述了 1.3 如何使用Nginx+Tomcat 如何优雅的做单机多实例的部署首先我们先来看Tomcat部署的场景分析 通常，我们对tomcat单机部署需求可以分为几种： 单实例单应用 (一个tomcat 一个web应用) 单实例多应用 (一个tomcat多个应用) 多实例单应用 (多个tomcat都部署一个应用) 多实例多应用 (多个tomcat部署多个不同的应用) 第一种场景：这是我们开发中经常用到的，如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。 第二种场景：是把多个应用程序的war包放在同一个tomcat的webapps目录，这样一来，关闭和启动tomca，或tomcat挂掉会影响所有项目。 第三种场景: 各个tomcat都运行同一个应用程序，对应地需要修改不同的监听端口，这种方式通常会和apache httpd或者nginx整合使用，做一些负载均衡的处理。 第四种场景: 相当于第一种场景的复数形式，除了修改不同的监听端口，没有本质区别。 一般来说，多实例部署tomcat，可以充分利用系统资源，不过这种方式，也有几个方面需要考虑： 多实例tomcat的更新维护，例如对tomcat进行升级等操作，我们需要考虑如何能“优雅”地对所有实例进行升级 尽量不要影响应用程序，在更新tomcat时，一不小心就把conf目录等全部覆盖，所以尽量要把配置文件和安装目录隔离 对于单应用来说，如果将war包分别置于各个tomcat的webapps目录，那么在发布新版本的war时，可能会出现某个实例更新失败，导致用户在访问时可能会访问到不同版本的web app，因此，比较好的方式就是所有tomcat实例都统一指向同一个应用程序，这样做，就可以多个tomcat用一份应用源码，简单部署，单机高可用也能实现（要配合nginx）. 本文重点阐述多实例应用的部署方案，但是为了解决上述几个问题，我们需要先来了解一下tomcat的一些基本情况。 我们的目标是要做到这样 首先来看一下tomcat的目录结构，一个刚解压出来的tomcat打包文件应该有以下几个目录 目录 作用 bin 主要存放脚本文件，例如比较常用的windows和linux系统中启动和关闭脚本 conf 主要存放配置文件，其中最重要的两个配置文件是server.xml和web.xml lib 主要存放tomcat运行所依赖的包 logs 主要存放运行时产生的日志文件，例如catalina.{date}.log等 temp 存放tomcat运行时产生的临时文件，例如开启了hibernate缓存的应用程序，会在该目录下生成一些文件 webapps 部署web应用程序的默认目录 work 主要存放由JSP文件生成的servlet（java文件以及最终编译生成的class文件） 再介绍两个tomcat中比较重要的概念（通常也是两个系统变量）—— CATALINA_HOME和CATALINA_BASE： CATALINA_HOME：即指向Tomcat安装路径的系统变量 CATALINA_BASE：即指向活跃配置路径的系统变量通过设置这两个变量，就可以将tomcat的安装目录和工作目录分离，从而实现tomcat多实例的部署。 Tomcat官方文档指出，CATALINA_HOME路径的路径下只需要包含bin和lib目录，这也就是支持tomcat软件运行的目录，而CATALINA_BASE设置的路径可以包括上述所有目录，不过其中bin和lib目录并不是必需的，缺省时会使用CATALINA_HOME中的bin和conf。如此，我们就可以使用一个tomcat安装目录部署多个tomcat实例，这样的好处在于方便升级，就可以在不影响tomcat实例的前提下，替换掉CATALINA_HOME指定的tomcat安装目录。 1.3.1 修改server.xml这里不详细分析server.xml中每一个配置项，网上也有很多这方面的文档。下面主要说明监听端口和Host的配置内容。在server.xml中配置了四个监听端口，分别是： Server Port：该端口用于监听关闭tomcat的shutdown命令，默认为8005 Connector Port：该端口用于监听HTTP的请求，默认为8080 AJP Port：该端口用于监听AJP（ Apache JServ Protocol ）协议上的请求，通常用于整合Apache Server等其他HTTP服务器，默认为8009 Redirect Port：重定向端口，出现在Connector配置中，如果该Connector仅支持非SSL的普通http请求，那么该端口会把https的请求转发到这个Redirect Port指定的端口，默认为8443 可见，如果不是使用AJP协议连接tomcat，只需要保证多实例中的Server Port和Connect Port不同即可。 1.3.2 下面来看我我是怎么配置的 这里我在Tomcat下创建了两个目录prerelease 和 release 最外层只留下lib 和bin这也就是支持tomcat软件运行的目录, 其他的几个目录全部移到新建的那几个文件夹下面， 接下来编辑server.xml 前面说了只要保证 Server Port和Connect Port不同即可。 &lt;Server port=&quot;8004&quot; shutdown=&quot;SHUTDOWN&quot;&gt; //改成一个唯一的端口 &lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8444&quot; /&gt; //改成一个唯一的端口 接着修改host节点 &lt;Host name=&quot;localhost&quot; appBase=&quot;/home/ec2-user/apache-tomcat-8.5.16/prerelease/webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; appbase 改成你现在这个实例webapps 所在的目录 最后因为小程序需要走HTTPS 所以需要配置ssl &lt;Connector port=&quot;8444&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; keystoreFile=&quot;/home/ec2-user/prerelease/Tomcat/preapi.atling.cn.jks&quot; //证书所在的位置 URIEncoding=&quot;UTF-8&quot; keystorePass=&quot;xxxx&quot; //证书申请的时候的密码 clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; ciphers=&quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, SSL_RSA_WITH_RC4_128_SHA&quot; /&gt; 然后再配置web.xml &lt;web-resource-collection &gt; &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; 接着在每个实例的根目录，像我就是在prerelease目录下创建一个启动Tomcat的脚本 # description: 启动tomcat多实例.# . /etc/init.d/functions RETVAL=$? # tomcat实例目录 export CATALINA_BASE=&quot;$PWD&quot; # tomcat安装目录 export CATALINA_HOME=&quot;/usr/local/src/apache-tomcat-8.5.16&quot; case &quot;$1&quot; in start) if [ -f $CATALINA_HOME/bin/startup.sh ];then echo $&quot;start Tomcat&quot; $CATALINA_HOME/bin/startup.sh fi ;; stop) if [ -f $CATALINA_HOME/bin/shutdown.sh ];then echo $&quot;stop Tomcat&quot; $CATALINA_HOME/bin/shutdown.sh fi ;; restart) if [ -f $CATALINA_HOME/bin/shutdown.sh ] &amp;&amp; [ -f $CATALINA_HOME/bin/ startup.sh ];then echo $&quot;restart Tomcat&quot; $CATALINA_HOME/bin/shutdown.sh &amp;&amp; $CATALINA_HOME/bin/startup.sh fi ;; *) echo $&quot;Usage: $0 {start|stop|restart}&quot; exit 1 ;; esac exit $RETVAL 启动和停止 只需要当前实例在根目录下执行 sudo ./startup.sh start 或者 sudo ./startup.sh stop startup.sh 是脚本文件的名称 Tomcat配置好了 接下来就是下载和配置Nginx 1.4 nginx 安装安装的话基本上看这篇文章就好了nginx安装 它里面有些问题需要注意下 他这个pcre 和zlib库的版本有问题 ，你可以去他这个链接的前面的地址例如 ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre 上面去找到最新的版本的链接就好了 还有就是最后一步Nginx 配置的时候只需要 ./configure --with-http_ssl_module --with-openssl=/opt/app/openet/oetal1/chenhe/openssl-1.0.1t 就好了，把ssl模块编译进去 最后就是Nginx的配置，我们前面启动了两个Tomcat实例分别是不同的端口，这里我们就用Nginx 通过不同的域名访问分别转发到不同的Tomcat上就好了 ，下面看我的Nginx的配置 server { listen 443 ; #监听443端口 HTTPS 默认的是443端口 ssl on; server_name api.atling.cn; #请求的域名 ssl_certificate /home/ec2-user/release/Nginx/1_api.atling.cn_bundle.crt; #ssl证书的路径 ssl_certificate_key /home/ec2-user/release/Nginx/2_api.atling.cn.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { # location / 表示拦截这个域名下的所有请求 proxy_pass https://127.0.0.1:8443; #转发到我们刚启动的Tomcat启动的对应的端口上去 } } server { listen 443 ; ssl on; server_name preapi.atling.cn; ssl_certificate /home/ec2-user/prerelease/Nginx/1_preapi.atling.cn_bundle.crt; ssl_certificate_key /home/ec2-user/prerelease/Nginx/2_preapi.atling.cn.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass https://127.0.0.1:8444; } } 这样重启Nginx 访问不同的域名就会转发到不同的Tomcat服务器 这样就实现了一台机器部署多套开发环境 域名我是在阿里云上面注册的域名，域名解析用的也是阿里云提供的云解析服务 ssl证书是申请的腾讯的 戳这里去申请域名 戳这里去申请ssl证书 这是我的解析记录 这是我配置的预发环境https://preapi.atling.cn 这是我配置的线上正式环境https://api.atling.cn 到这里为止服务端的环境就算配置好了]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从view的工作原理看listview的巧妙设计(activity和window的创建过程)]]></title>
    <url>%2F2017%2F04%2F25%2F%E4%BB%8Eview%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%9C%8Blistview%E7%9A%84%E5%B7%A7%E5%A6%99%E8%AE%BE%E8%AE%A1-1%2F</url>
    <content type="text"><![CDATA[activity和window的创建过程 在我们日常开发中用的最多用法最复杂的系统原生组件当属Listview了，在显示同类的数据或者规则化的数据的时候用listview能带来良好的体验，而对于数据很多的情况只要滑动就能把屏幕外的数据移入屏幕当中。 早期Android的虚拟机是基于寄存器的Dalvik，它的最大堆大小一般是16M，有的机器为24M。我们平常看到的OutOfMemory的错误，通常 是堆内存溢出。移动开发和web开发的最大的区别是设备资源受限，对一般手机应用，这个资源是相当有限的，堆内存的上限值只有16M，但是listview是怎么做到加载非常多的数据的时候而不会出现oom甚至非常流畅，连内存占用都没有增多呢？如果搞清楚了listview的实现原理，对日常开发中我们自定义复杂viewGroup也有着很大的参考价值，怀着这样的好奇心，我开始尝试着去分析listView的源码。 但是在去解决这个问题之前，我们还必须了解一个问题就是整个view的工作原理，我们大家都知道，view的工作流程主要是指 measure layout draw这三个过程，即measure确定view的大小，layout确定view的位置，而draw则是将view显示到屏幕上，但是如果细心的同学则会发现，一个view无论多么简单的view在整个工作流程中都至少会经历两次以上一般四次measure，二次layout过后在最后执行draw将view绘制到屏幕上。 view的工作原理浅析 为了清楚的了解这些原因，我们需要先知道Activity是如何显示的，由于篇幅的原因本文主要从ActivityThread的handleLaunchActivity() 方法讲起，前面具体的用户调用了StartActivity之后怎么通知Ams（ActivityManagerService）暂停当前正在执行的activity,然后新启动的activity的一些重要的数据类ProcessRecord ActivityRecord, TaskRecord等的创建，启动类型，权限，运行环境等一系例的检查接下来会专门写一篇文章来介绍整个Activity的启动过程和ActivityManagerService的工作原理，这里我们先大概有着么个概念。 经过前面一系例的调用，最后来到ActivityThread类，顾名思义就是我们常说的大名鼎鼎的主线程，UI线程类。在他的handleLaunchActivity（ActivityClientRecord r, Intent customIntent）方法中我们挑最重要的几行代码如下： 123456789101112131415161718192021private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); ... if (localLOGV) Slog.v( TAG, "Handling launch of " + r); Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); ... &#125;&#125; 在handleLaunchActivity方法中我们看到有调用到了performLaunchActivity(r, customIntent);我们跟进去看看这个方法里面做了什么事情： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")"); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to instantiate activity " + component + ": " + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; ... return activity;&#125; 这个方法比较长，我们同样来看我们最关心的重要的几行代码，首先通过mInstrumentation.newActivity( cl, component.getClassName(), r.intent);创建一个activity实例，然后又调用createBaseContextForActivity创建一个上下文context，然后有味activity设置主题等，接下来 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);调用我们的activity中的oncreate方法，在我们的activity的onCreate() 方法中我们会调用setContextView(resId)。在onCreate方法后，又接着调用activity.performStart(); 也就是我们Activity的生命周期onstart。 我们先去看看mInstrumentation.newActivity( cl, component.getClassName(), r.intent)是怎样创建出一个activity实例的。mInstrumentation类型是Instrumentation 类路径在frameworks/base/core/java/android/app/Instrumentation.java 12345678910111213 public Activity newActivity(Class&lt;?&gt; clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance) throws InstantiationException, IllegalAccessException &#123; Activity activity = (Activity)clazz.newInstance(); ActivityThread aThread = null; activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances)lastNonConfigurationInstance, new Configuration(), null); return activity;&#125; 到这里我们神秘的activity终于解开了面纱，原来是通过反射直接new出来一个Activity实例，接着调用activity的attach方法，在这个attach方法中将我们的activity与window联系在了一起，先去看看activity的attach方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435 final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, IVoiceInteractor voiceInteractor) &#123; attachBaseContext(context); mFragments.attachActivity(this, mContainer, null); mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; mUiThread = Thread.currentThread(); mMainThread = aThread;... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; &#125; 在这个方法中首先通过PolicyManager.makeNewWindow(this); 创建一个window实例，是PhoneWindow类型，这个类的路径在frameworks/base/policy/src/com/android/internal/policy/impl下面，接下来mWindow.setCallback(this);,因为activity实现了window。callback。然后再为mMainThread，token等赋值，setWindowManager等。这样我们一个window对象就创建好了，但实际上window只是一个抽象的概念，真正显示在屏幕上的是view，而window又是怎样与我们的根 view，ViewRootImpl联系在一起的呢，实际上ViewRootImpl也不是真正能展示的view，它只是viewPrant,View的一些接口，真正能展示的是它的一个叫mViews的属性，而mViews就是我们所熟知的DecorView，接下来我们就去看看window是怎么通过ViewRootImpl和DecorView联系在一起的。 通过上面的代码我们已经知道，在创建好了activity实例之后，会回调activity的onCreate()方法，而在onCreate()方法中我们回调用setContentView。而window的setContentView方法是交给具体的实现类来实现的，我们去看下window的实现类PhoneWindow的setContentView方法： 1234567891011121314151617181920212223@Override public void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; &#125; 在这个如果mContentParent是空的话就会调用installDecor();方法，DecorView是一个继承自FrameLayout的view，而mContentParent是DecorView中contentviewGroup类型的。我们先看看installDecor();方法： 12345678910111213141516171819private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); .... &#125; &#125; 在这里面首先如果mDecor是空的话就用generateDecor();方法创建一个DecorView； 123 protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 接着判断mContentParent如果是空的话调用generateLayout(mDecor);创建一个 mContentParent；在这个方法中主要是通过layoutInflate创建一个view 1234567891011121314151617181920212223242526 View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException("Window couldn't find content container view"); &#125;``` 然后把这个view加入到decorView中，从这里可以看到contentParent是一个ViewGroup在这里window和要显示的DecorView 都已经创建好了，现在到了最关键的一步了就是ViewRootImpl是怎么将window和我们的View也就是DecorView联系在一起呢？前面我们介绍可在ActivityThread的handleLaunchActivity方法中创建了一个activity实例并调用了onCreate 、onStart生命周期创建了window和Decorview之后```java Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); 看接着又会通过handleResumeActivity调用activity的onResume生命周期方法。 1234567891011121314151617181920212223242526272829303132333435363738394041 final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; ... r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; ...&#125; 首先调用performResumeActivity(token, clearHide);方法，这个方法中主要调用了activity的onResume方法，然后拿到一个ActivityClientRecord，接下来拿到我们创建好的widow对象，decorView对象，再通过widow获取windowmanager，然后调用widowManager的addView方法，然后最后调用 r.activity.makeVisible();方法,makeVisiable只要是调用了DecorView的setVisible方法，看到这里，我们还是没有看到viewRootImpl的身影，别急，我们继续 wm.addView(decor, l);看进去。 windowmanager是一个接口，又继承了ViewManager，而在Viewmanager接口中定义了三个惊天地泣鬼神的方法 12345678910111213141516 public interface ViewManager&#123; /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.BadTokenException&#125; for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.InvalidDisplayException&#125; if the window is on a * secondary &#123;@link Display&#125; and the specified display can't be found * (see &#123;@link android.app.Presentation&#125;). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 我们增加，更新，删除一个view都是在这个接口中定义的，然后我们去看下它的实现类windowManagerImpl类，路径是frameworks/base/core/java/android/view/windowManagerImpl.java, 1234567891011121314 @Overridepublic void addView(View view, ViewGroup.LayoutParams params) &#123; mGlobal.addView(view, params, mDisplay, mParentWindow);&#125;@Overridepublic void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; mGlobal.updateViewLayout(view, params);&#125;@Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; 而在个windowmanagerimpl类中并没有真正实现这三个方法，而是通过WindowManagerGlobal来代理实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; ... int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException("View " + view + " has already been added to the window manager."); &#125; // The previous removeView() had not completed executing. Now it has. &#125;... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; &#125; 在这里我们可以看到创建了一个ViewRootImpl对象，将这个对象 还有我们传过来的DecorView保存在list中，然后调用root.setView方法，把decorView保存到ViewRootImpl的成员变量mViews中。到这里我们的Activity，window，decorView都已经创建完成，并且通过ViewRootImpl把window和decorView联系在了一起，activity也走过了oncreate start resume等生命周期方法。 通过viewRootImpl的setView方法把decorView添加到ViewRootImpl中之后，在ViewRootImpl的setView方法中： 1234// Schedule the first layout -before- adding to the window// manager, to make sure we do the relayout before receiving// any other events from the system.requestLayout(); 在setView内部会通过requestLayout来完成异步刷新请求，requestLayout最终会调用performTraversals方法来完成View的绘制，源码注释如下：差不多意思就是在添加Window之前先完成第一次layout布局过程，以确保在收到任何系统事件后面重新布局; 12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 在这里首先会调用checkThread方法 123456 void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; 这也就是为什么我们不能在子线程中更新UI的原因了，然后调用scheduleTraversals ()方法，这个方法最终又会调用到performTraversals()方法。该方法就是Android系统View树遍历工作的核心。一眼看去，发现这个方法挺长的足足有七八百行，但是逻辑是非常清晰的，其执行过程可简单概括为根据之前所有设置好的状态，判断是否需要计算视图大小（measure）、是否需要重新安置视图的位置（layout），以及是否需要重绘（draw）视图， 具体流程如下（此图为盗图，有时间我会自己画一个 －－）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774 private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView; if (DBG) &#123; System.out.println("======================================"); System.out.println("performTraversals"); host.debug(); &#125; if (host == null || !mAdded) return; mIsInTraversal = true; mWillDrawSoon = true; boolean windowSizeMayChange = false; boolean newSurface = false; boolean surfaceChanged = false; WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; final int viewVisibility = getHostVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility || mNewSurfaceNeeded; WindowManager.LayoutParams params = null; if (mWindowAttributesChanged) &#123; mWindowAttributesChanged = false; surfaceChanged = true; params = lp; &#125; CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo(); if (compatibilityInfo.supportsScreen() == mLastInCompatMode) &#123; params = lp; mFullRedrawNeeded = true; mLayoutRequested = true; if (mLastInCompatMode) &#123; params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW; mLastInCompatMode = false; &#125; else &#123; params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW; mLastInCompatMode = true; &#125; &#125; mWindowAttributesChangesFlag = 0; Rect frame = mWinFrame; if (mFirst) &#123; mFullRedrawNeeded = true; mLayoutRequested = true; if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) &#123; // NOTE -- system code, won't try to do compat mode. Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; &#125; else &#123; DisplayMetrics packageMetrics = mView.getContext().getResources().getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; &#125; // We used to use the following condition to choose 32 bits drawing caches: // PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888 // However, windows are now always 32 bits by default, so choose 32 bits mAttachInfo.mUse32BitDrawingCache = true; mAttachInfo.mHasWindowFocus = false; mAttachInfo.mWindowVisibility = viewVisibility; mAttachInfo.mRecomputeGlobalAttributes = false; viewVisibilityChanged = false; mLastConfiguration.setTo(host.getResources().getConfiguration()); mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility; // Set the layout direction if it has not been set before (inherit is the default) if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123; host.setLayoutDirection(mLastConfiguration.getLayoutDirection()); &#125; host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); //Log.i(TAG, "Screen on initialized: " + attachInfo.mKeepScreenOn); &#125; else &#123; desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123; if (DEBUG_ORIENTATION) Log.v(TAG, "View " + host + " resized to: " + frame); mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; &#125; &#125; if (viewVisibilityChanged) &#123; mAttachInfo.mWindowVisibility = viewVisibility; host.dispatchWindowVisibilityChanged(viewVisibility); if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) &#123; destroyHardwareResources(); &#125; if (viewVisibility == View.GONE) &#123; // After making a window gone, we will count it as being // shown for the first time the next time it gets focus. mHasHadWindowFocus = false; &#125; &#125; // Execute enqueued actions on every traversal in case a detached view enqueued an action getRunQueue().executeActions(mAttachInfo.mHandler); boolean insetsChanged = false; boolean layoutRequested = mLayoutRequested &amp;&amp; !mStopped; if (layoutRequested) &#123; final Resources res = mView.getContext().getResources(); if (mFirst) &#123; // make sure touch mode code executes by setting cached value // to opposite of the added touch mode. mAttachInfo.mInTouchMode = !mAddedTouchMode; ensureTouchModeLocally(mAddedTouchMode); &#125; else &#123; if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123; insetsChanged = true; &#125; if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123; insetsChanged = true; &#125; if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123; insetsChanged = true; &#125; if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123; mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets); if (DEBUG_LAYOUT) Log.v(TAG, "Visible insets changing to: " + mAttachInfo.mVisibleInsets); &#125; if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; windowSizeMayChange = true; if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) &#123; // NOTE -- system code, won't try to do compat mode. Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; &#125; else &#123; DisplayMetrics packageMetrics = res.getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; &#125; &#125; &#125; // Ask host how big it wants to be windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; if (collectViewAttributes()) &#123; params = lp; &#125; if (mAttachInfo.mForceReportNewAttributes) &#123; mAttachInfo.mForceReportNewAttributes = false; params = lp; &#125; if (mFirst || mAttachInfo.mViewVisibilityChanged) &#123; mAttachInfo.mViewVisibilityChanged = false; int resizeMode = mSoftInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST; // If we are in auto resize mode, then we need to determine // what mode to use now. if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123; final int N = mAttachInfo.mScrollContainers.size(); for (int i=0; i&lt;N; i++) &#123; if (mAttachInfo.mScrollContainers.get(i).isShown()) &#123; resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE; &#125; &#125; if (resizeMode == 0) &#123; resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN; &#125; if ((lp.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) &#123; lp.softInputMode = (lp.softInputMode &amp; ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode; params = lp; &#125; &#125; &#125; if (params != null) &#123; if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123; if (!PixelFormat.formatHasAlpha(params.format)) &#123; params.format = PixelFormat.TRANSLUCENT; &#125; &#125; mAttachInfo.mOverscanRequested = (params.flags &amp; WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0; &#125; if (mApplyInsetsRequested) &#123; mApplyInsetsRequested = false; mLastOverscanRequested = mAttachInfo.mOverscanRequested; dispatchApplyInsets(host); if (mLayoutRequested) &#123; // Short-circuit catching a new layout request here, so // we don't need to go through two layout passes when things // change due to fitting system windows, which can happen a lot. windowSizeMayChange |= measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); &#125; &#125; if (layoutRequested) &#123; // Clear this now, so that if anything requests a layout in the // rest of this function we will catch it and re-run a full // layout pass. mLayoutRequested = false; &#125; boolean windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp; frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp; frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight)); // Determine whether to compute insets. // If there are no inset listeners remaining then we may still need to compute // insets in case the old insets were non-empty and must be reset. final boolean computesInternalInsets = mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets; boolean insetsPending = false; int relayoutResult = 0; if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null) &#123; if (viewVisibility == View.VISIBLE) &#123; // If this window is giving internal insets to the window // manager, and it is being added or changing its visibility, // then we want to first give the window manager "fake" // insets to cause it to effectively ignore the content of // the window during layout. This avoids it briefly causing // other windows to resize/move based on the raw frame of the // window, waiting until we can finish laying out this window // and get back to the window manager with the ultimately // computed insets. insetsPending = computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged); &#125; if (mSurfaceHolder != null) &#123; mSurfaceHolder.mSurfaceLock.lock(); mDrawingAllowed = true; &#125; boolean hwInitialized = false; boolean contentInsetsChanged = false; boolean hadSurface = mSurface.isValid(); try &#123; if (DEBUG_LAYOUT) &#123; Log.i(TAG, "host=w:" + host.getMeasuredWidth() + ", h:" + host.getMeasuredHeight() + ", params=" + params); &#125; if (mAttachInfo.mHardwareRenderer != null) &#123; // relayoutWindow may decide to destroy mSurface. As that decision // happens in WindowManager service, we need to be defensive here // and stop using the surface in case it gets destroyed. mAttachInfo.mHardwareRenderer.pauseSurface(mSurface); &#125; final int surfaceGenerationId = mSurface.getGenerationId(); relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); if (!mDrawDuringWindowsAnimating &amp;&amp; (relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) &#123; mWindowsAnimating = true; &#125; if (DEBUG_LAYOUT) Log.v(TAG, "relayout: frame=" + frame.toShortString() + " overscan=" + mPendingOverscanInsets.toShortString() + " content=" + mPendingContentInsets.toShortString() + " visible=" + mPendingVisibleInsets.toShortString() + " visible=" + mPendingStableInsets.toShortString() + " surface=" + mSurface); if (mPendingConfiguration.seq != 0) &#123; if (DEBUG_CONFIGURATION) Log.v(TAG, "Visible with new config: " + mPendingConfiguration); updateConfiguration(mPendingConfiguration, !mFirst); mPendingConfiguration.seq = 0; &#125; final boolean overscanInsetsChanged = !mPendingOverscanInsets.equals( mAttachInfo.mOverscanInsets); contentInsetsChanged = !mPendingContentInsets.equals( mAttachInfo.mContentInsets); final boolean visibleInsetsChanged = !mPendingVisibleInsets.equals( mAttachInfo.mVisibleInsets); final boolean stableInsetsChanged = !mPendingStableInsets.equals( mAttachInfo.mStableInsets); if (contentInsetsChanged) &#123; if (mWidth &gt; 0 &amp;&amp; mHeight &gt; 0 &amp;&amp; lp != null &amp;&amp; ((lp.systemUiVisibility|lp.subtreeSystemUiVisibility) &amp; View.SYSTEM_UI_LAYOUT_FLAGS) == 0 &amp;&amp; mSurface != null &amp;&amp; mSurface.isValid() &amp;&amp; !mAttachInfo.mTurnOffWindowResizeAnim &amp;&amp; mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled() &amp;&amp; lp != null &amp;&amp; !PixelFormat.formatHasAlpha(lp.format) &amp;&amp; !mBlockResizeBuffer) &#123; disposeResizeBuffer();// TODO: Again....// if (mResizeBuffer == null) &#123;// mResizeBuffer = mAttachInfo.mHardwareRenderer.createDisplayListLayer(// mWidth, mHeight);// &#125;// mResizeBuffer.prepare(mWidth, mHeight, false);// RenderNode layerRenderNode = mResizeBuffer.startRecording();// HardwareCanvas layerCanvas = layerRenderNode.start(mWidth, mHeight);// try &#123;// final int restoreCount = layerCanvas.save();//// int yoff;// final boolean scrolling = mScroller != null// &amp;&amp; mScroller.computeScrollOffset();// if (scrolling) &#123;// yoff = mScroller.getCurrY();// mScroller.abortAnimation();// &#125; else &#123;// yoff = mScrollY;// &#125;//// layerCanvas.translate(0, -yoff);// if (mTranslator != null) &#123;// mTranslator.translateCanvas(layerCanvas);// &#125;//// RenderNode renderNode = mView.mRenderNode;// if (renderNode != null &amp;&amp; renderNode.isValid()) &#123;// layerCanvas.drawDisplayList(renderNode, null,// RenderNode.FLAG_CLIP_CHILDREN);// &#125; else &#123;// mView.draw(layerCanvas);// &#125;//// drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);//// mResizeBufferStartTime = SystemClock.uptimeMillis();// mResizeBufferDuration = mView.getResources().getInteger(// com.android.internal.R.integer.config_mediumAnimTime);//// layerCanvas.restoreToCount(restoreCount);// layerRenderNode.end(layerCanvas);// layerRenderNode.setCaching(true);// layerRenderNode.setLeftTopRightBottom(0, 0, mWidth, mHeight);// mTempRect.set(0, 0, mWidth, mHeight);// &#125; finally &#123;// mResizeBuffer.endRecording(mTempRect);// &#125;// mAttachInfo.mHardwareRenderer.flushLayerUpdates(); &#125; mAttachInfo.mContentInsets.set(mPendingContentInsets); if (DEBUG_LAYOUT) Log.v(TAG, "Content insets changing to: " + mAttachInfo.mContentInsets); &#125; if (overscanInsetsChanged) &#123; mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets); if (DEBUG_LAYOUT) Log.v(TAG, "Overscan insets changing to: " + mAttachInfo.mOverscanInsets); // Need to relayout with content insets. contentInsetsChanged = true; &#125; if (stableInsetsChanged) &#123; mAttachInfo.mStableInsets.set(mPendingStableInsets); if (DEBUG_LAYOUT) Log.v(TAG, "Decor insets changing to: " + mAttachInfo.mStableInsets); // Need to relayout with content insets. contentInsetsChanged = true; &#125; if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested) &#123; mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility; mLastOverscanRequested = mAttachInfo.mOverscanRequested; mApplyInsetsRequested = false; dispatchApplyInsets(host); &#125; if (visibleInsetsChanged) &#123; mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets); if (DEBUG_LAYOUT) Log.v(TAG, "Visible insets changing to: " + mAttachInfo.mVisibleInsets); &#125; if (!hadSurface) &#123; if (mSurface.isValid()) &#123; // If we are creating a new surface, then we need to // completely redraw it. Also, when we get to the // point of drawing it we will hold off and schedule // a new traversal instead. This is so we can tell the // window manager about all of the windows being displayed // before actually drawing them, so it can display then // all at once. newSurface = true; mFullRedrawNeeded = true; mPreviousTransparentRegion.setEmpty(); if (mAttachInfo.mHardwareRenderer != null) &#123; try &#123; hwInitialized = mAttachInfo.mHardwareRenderer.initialize( mSurface); &#125; catch (OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return; &#125; &#125; &#125; &#125; else if (!mSurface.isValid()) &#123; // If the surface has been removed, then reset the scroll // positions. if (mLastScrolledFocus != null) &#123; mLastScrolledFocus.clear(); &#125; mScrollY = mCurScrollY = 0; if (mScroller != null) &#123; mScroller.abortAnimation(); &#125; disposeResizeBuffer(); // Our surface is gone if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123; mAttachInfo.mHardwareRenderer.destroy(); &#125; &#125; else if (surfaceGenerationId != mSurface.getGenerationId() &amp;&amp; mSurfaceHolder == null &amp;&amp; mAttachInfo.mHardwareRenderer != null) &#123; mFullRedrawNeeded = true; try &#123; mAttachInfo.mHardwareRenderer.updateSurface(mSurface); &#125; catch (OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return; &#125; &#125; &#125; catch (RemoteException e) &#123; &#125; if (DEBUG_ORIENTATION) Log.v( TAG, "Relayout returned: frame=" + frame + ", surface=" + mSurface); mAttachInfo.mWindowLeft = frame.left; mAttachInfo.mWindowTop = frame.top; // !!FIXME!! This next section handles the case where we did not get the // window size we asked for. We should avoid this by getting a maximum size from // the window session beforehand. if (mWidth != frame.width() || mHeight != frame.height()) &#123; mWidth = frame.width(); mHeight = frame.height(); &#125; if (mSurfaceHolder != null) &#123; // The app owns the surface; tell it about what is going on. if (mSurface.isValid()) &#123; // XXX .copyFrom() doesn't work! //mSurfaceHolder.mSurface.copyFrom(mSurface); mSurfaceHolder.mSurface = mSurface; &#125; mSurfaceHolder.setSurfaceFrameSize(mWidth, mHeight); mSurfaceHolder.mSurfaceLock.unlock(); if (mSurface.isValid()) &#123; if (!hadSurface) &#123; mSurfaceHolder.ungetCallbacks(); mIsCreating = true; mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder); SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks(); if (callbacks != null) &#123; for (SurfaceHolder.Callback c : callbacks) &#123; c.surfaceCreated(mSurfaceHolder); &#125; &#125; surfaceChanged = true; &#125; if (surfaceChanged) &#123; mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder, lp.format, mWidth, mHeight); SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks(); if (callbacks != null) &#123; for (SurfaceHolder.Callback c : callbacks) &#123; c.surfaceChanged(mSurfaceHolder, lp.format, mWidth, mHeight); &#125; &#125; &#125; mIsCreating = false; &#125; else if (hadSurface) &#123; mSurfaceHolder.ungetCallbacks(); SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks(); mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder); if (callbacks != null) &#123; for (SurfaceHolder.Callback c : callbacks) &#123; c.surfaceDestroyed(mSurfaceHolder); &#125; &#125; mSurfaceHolder.mSurfaceLock.lock(); try &#123; mSurfaceHolder.mSurface = new Surface(); &#125; finally &#123; mSurfaceHolder.mSurfaceLock.unlock(); &#125; &#125; &#125; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123; if (hwInitialized || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) &#123; final Rect surfaceInsets = params != null ? params.surfaceInsets : null; mAttachInfo.mHardwareRenderer.setup(mWidth, mHeight, surfaceInsets); if (!hwInitialized) &#123; mAttachInfo.mHardwareRenderer.invalidate(mSurface); mFullRedrawNeeded = true; &#125; &#125; &#125; if (!mStopped) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123; int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, "Ooops, something changed! mWidth=" + mWidth + " measuredWidth=" + host.getMeasuredWidth() + " mHeight=" + mHeight + " measuredHeight=" + host.getMeasuredHeight() + " coveredInsetsChanged=" + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) &#123; width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (lp.verticalWeight &gt; 0.0f) &#123; height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (measureAgain) &#123; if (DEBUG_LAYOUT) Log.v(TAG, "And hey let's measure once more: width=" + width + " height=" + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; layoutRequested = true; &#125; &#125; &#125; else &#123; // Not the first pass and no window/insets/visibility change but the window // may have moved and we need check that and if so to update the left and right // in the attach info. We translate only the window frame since on window move // the window manager tells us only for the new frame but the insets are the // same and we do not want to translate them more than once. // TODO: Well, we are checking whether the frame has changed similarly // to how this is done for the insets. This is however incorrect since // the insets and the frame are translated. For example, the old frame // was (1, 1 - 1, 1) and was translated to say (2, 2 - 2, 2), now the new // reported frame is (2, 2 - 2, 2) which implies no change but this is not // true since we are comparing a not translated value to a translated one. // This scenario is rare but we may want to fix that. final boolean windowMoved = (mAttachInfo.mWindowLeft != frame.left || mAttachInfo.mWindowTop != frame.top); if (windowMoved) &#123; if (mTranslator != null) &#123; mTranslator.translateRectInScreenToAppWinFrame(frame); &#125; mAttachInfo.mWindowLeft = frame.left; mAttachInfo.mWindowTop = frame.top; &#125; &#125; final boolean didLayout = layoutRequested &amp;&amp; !mStopped; boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout(lp, desiredWindowWidth, desiredWindowHeight); // By this point all views have been sized and positioned // We can compute the transparent area if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123; // start out transparent // TODO: AVOID THAT CALL BY CACHING THE RESULT? host.getLocationInWindow(mTmpLocation); mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1], mTmpLocation[0] + host.mRight - host.mLeft, mTmpLocation[1] + host.mBottom - host.mTop); host.gatherTransparentRegion(mTransparentRegion); if (mTranslator != null) &#123; mTranslator.translateRegionInWindowToScreen(mTransparentRegion); &#125; if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123; mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try &#123; mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; if (DBG) &#123; System.out.println("======================================"); System.out.println("performTraversals -- after setFrame"); host.debug(); &#125; &#125; if (triggerGlobalLayoutListener) &#123; mAttachInfo.mRecomputeGlobalAttributes = false; mAttachInfo.mTreeObserver.dispatchOnGlobalLayout(); &#125; if (computesInternalInsets) &#123; // Clear the original insets. final ViewTreeObserver.InternalInsetsInfo insets = mAttachInfo.mGivenInternalInsets; insets.reset(); // Compute new insets in place. mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets); mAttachInfo.mHasNonEmptyGivenInternalInsets = !insets.isEmpty(); // Tell the window manager. if (insetsPending || !mLastGivenInsets.equals(insets)) &#123; mLastGivenInsets.set(insets); // Translate insets to screen coordinates if needed. final Rect contentInsets; final Rect visibleInsets; final Region touchableRegion; if (mTranslator != null) &#123; contentInsets = mTranslator.getTranslatedContentInsets(insets.contentInsets); visibleInsets = mTranslator.getTranslatedVisibleInsets(insets.visibleInsets); touchableRegion = mTranslator.getTranslatedTouchableArea(insets.touchableRegion); &#125; else &#123; contentInsets = insets.contentInsets; visibleInsets = insets.visibleInsets; touchableRegion = insets.touchableRegion; &#125; try &#123; mWindowSession.setInsets(mWindow, insets.mTouchableInsets, contentInsets, visibleInsets, touchableRegion); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; boolean skipDraw = false; if (mFirst) &#123; // handle first focus request if (DEBUG_INPUT_RESIZE) Log.v(TAG, "First: mView.hasFocus()=" + mView.hasFocus()); if (mView != null) &#123; if (!mView.hasFocus()) &#123; mView.requestFocus(View.FOCUS_FORWARD); if (DEBUG_INPUT_RESIZE) Log.v(TAG, "First: requested focused view=" + mView.findFocus()); &#125; else &#123; if (DEBUG_INPUT_RESIZE) Log.v(TAG, "First: existing focused view=" + mView.findFocus()); &#125; &#125; if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) &#123; // The first time we relayout the window, if the system is // doing window animations, we want to hold of on any future // draws until the animation is done. mWindowsAnimating = true; &#125; &#125; else if (mWindowsAnimating) &#123; skipDraw = true; &#125; mFirst = false; mWillDrawSoon = false; mNewSurfaceNeeded = false; mViewVisibility = viewVisibility; if (mAttachInfo.mHasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123; final boolean imTarget = WindowManager.LayoutParams .mayUseInputMethod(mWindowAttributes.flags); if (imTarget != mLastWasImTarget) &#123; mLastWasImTarget = imTarget; InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null &amp;&amp; imTarget) &#123; imm.startGettingWindowFocus(mView); imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags); &#125; &#125; &#125; // Remember if we must report the next draw. if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123; mReportNextDraw = true; &#125; boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE; if (!cancelDraw &amp;&amp; !newSurface) &#123; if (!skipDraw || mReportNextDraw) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw(); &#125; &#125; else &#123; if (viewVisibility == View.VISIBLE) &#123; // Try again scheduleTraversals(); &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).endChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; &#125; mIsInTraversal = false; &#125; 其实别看代码这么长，我们只关心三个主要的流程，measure layout draw，这里面有一个贯穿始终的变量mFirst，mFirst默认是false，我们先看到163行： 123// Ask host how big it wants to be windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); 这里会调用一个measureHierarchy方法Ask host how big it wants to be。也就是我们的measure我们进去看一看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; int childWidthMeasureSpec; int childHeightMeasureSpec; boolean windowSizeMayChange = false; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(TAG, "Measuring " + host + " in display " + desiredWindowWidth + "x" + desiredWindowHeight + "..."); boolean goodMeasure = false; if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; // On large screens, we don't want to allow dialogs to just // stretch to fill the entire width of the screen to display // one line of text. First try doing the layout at a smaller // size to see if it will fit. final DisplayMetrics packageMetrics = res.getDisplayMetrics(); res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, true); int baseSize = 0; if (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123; baseSize = (int)mTmpValue.getDimension(packageMetrics); &#125; if (DEBUG_DIALOG) Log.v(TAG, "Window " + mView + ": baseSize=" + baseSize); if (baseSize != 0 &amp;&amp; desiredWindowWidth &gt; baseSize) &#123; childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); if (DEBUG_DIALOG) Log.v(TAG, "Window " + mView + ": measured (" + host.getMeasuredWidth() + "," + host.getMeasuredHeight() + ")"); if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == 0) &#123; goodMeasure = true; &#125; else &#123; // Didn't fit in that size... try expanding a bit. baseSize = (baseSize+desiredWindowWidth)/2; if (DEBUG_DIALOG) Log.v(TAG, "Window " + mView + ": next baseSize=" + baseSize); childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); if (DEBUG_DIALOG) Log.v(TAG, "Window " + mView + ": measured (" + host.getMeasuredWidth() + "," + host.getMeasuredHeight() + ")"); if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == 0) &#123; if (DEBUG_DIALOG) Log.v(TAG, "Good!"); goodMeasure = true; &#125; &#125; &#125; &#125; if (!goodMeasure) &#123; childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123; windowSizeMayChange = true; &#125; &#125; if (DBG) &#123; System.out.println("======================================"); System.out.println("performTraversals -- after measure"); host.debug(); &#125; return windowSizeMayChange; &#125; 在这里它说它们不想让一个对话框拉升成屏幕的大小去显示一行文本，而是先尝试给一个小点的值看看可不可以。但是在我的观察中，我在一个普通的view的onmeasure方法中打个断点，看它的调用栈，无论什么情况下发现这个小size尝试总是不是一个goodMeasure，也就是说总是会measure两次。 接下来我们再回到刚才的代码中，看到第410行如下： 12345678910111213141516171819202122if (!hadSurface) &#123; if (mSurface.isValid()) &#123; // If we are creating a new surface, then we need to // completely redraw it. Also, when we get to the // point of drawing it we will hold off and schedule // a new traversal instead. This is so we can tell the // window manager about all of the windows being displayed // before actually drawing them, so it can display then // all at once. newSurface = true; mFullRedrawNeeded = true; mPreviousTransparentRegion.setEmpty(); if (mAttachInfo.mHardwareRenderer != null) &#123; try &#123; hwInitialized = mAttachInfo.mHardwareRenderer.initialize( mSurface); &#125; catch (OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return; &#125; &#125; 因为第一次绘制所以hadSurface为false在里面把newSurface致为true，这个就是导致performTraversals执行两次，measure 执行2～4次，layout执行两次的罪魁祸首，我们先看下它的解释，大概意思是如果新建一个surface，我们需要完全重新绘制，因此我们将重新进行一次遍历来推迟到达绘制的时间点，在widowmanager 绘制之前我们要确保所有的window都是待展示，这样我们就可以只需要一次就能把它们全部展示。按理说在进行surface的draw之前，Measure layout过程都应该结束了（这里还没有深入研究，这里个人猜测可能与surface的实现相关，如果有知道的可以在评论区讨论下） 再看580行我们看到其实如果你的布局中有Weight大于0的还会再进行一次Measure。把剩下的大小再平分给每个Weight大于0的view。 在看到616行开始 1234567final boolean didLayout = layoutRequested &amp;&amp; !mStopped; boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout(lp, desiredWindowWidth, desiredWindowHeight); ... &#125; 这里的layoutRequested在我们的requestlayout方法中已经致为true了。mStopped的一搬石false，所以就会进入我们的performLayout方法中。再看到750行： 12345678910111213141516171819202122if (!cancelDraw &amp;&amp; !newSurface) &#123; if (!skipDraw || mReportNextDraw) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw(); &#125; &#125; else &#123; if (viewVisibility == View.VISIBLE) &#123; // Try again scheduleTraversals(); &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).endChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; &#125; 在这个if判断中，cancekDraw 一般都是false，然后这个newSurface就是我刚说的罪魁祸首，因为刚刚在创建surface的时候将这个变量致为true所以在这里直接进入else代码中，这里就看到关键的代码 //Try agin scheduleTraversals(); 再重新进行一遍view树的遍历，但是在第二次遍历中newSurface已经为false了所以就进入 performDraw();方法，到此我们的view就真正的显示在屏幕上了。 到此我们的activity的创建和view的工作原理就已经讲完了。之所以会选择在讲listview的原理之前讲view的工作原理，是因为还记得我们刚说的performTraversals会执行两次，所以layout也会执行两次，而listview在实现的过程中巧妙的利用了这一点。 因为本人能力有限，语言组织也不太好所以肯定会有很多披露，欢迎大家批评指正。下一节我们就真正进入listView的源码分析。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水波纹activity切换动画]]></title>
    <url>%2F2017%2F02%2F10%2F%E6%B0%B4%E6%B3%A2%E7%BA%B9activity%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[其实android有提供 activity之间切换动画的API overridePendingTransition(intres,outres)只要传入两个动画布局文件，就可以实现淡入淡出，旋转，缩放，平移等动画，但是这些动画看起来太平常了，这时候我们就需要一点炫酷点的东西， 大致效果如下图： 效果是当你在一个activity点击一个view 然后要切换到另一个activity，这时候就会以点击的这个view为中心把第二个activity的显示内容以一个水波纹圆的形势往四周散开。 具体实现的思路主要是在第二个activity中获取到根试图DecorView,然后创建一个view，这个view是以第一个activity的视图为背景，然后把第二个activity的视图裁剪成一个圆随着时间半径逐渐变大，效果就好像是第二个activity以一个圆的形势在第一个activity上逐渐变大。 具体代码可以请看github]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说Gradle的那些事儿]]></title>
    <url>%2F2016%2F12%2F21%2F%E8%AF%B4%E8%AF%B4Gradle%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[android Gradle系列分析之Groovy和Gradle基础学习了解1 Gradle是什么Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。面向Java应用为主。当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。 2013年5月16日，在I/O大会上，谷歌推出新的Android开发环境——Android Studio，并对开发者控制台进行了改进，增加了五个新的功能，并且使用Gradle作为工程的构建工具。 1.1 Groovy介绍因为Gradle是基于Groovy语言的，所以在讲之前，我们先来稍微了解下Groovy。Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy 可以使用其他 Java 语言编写的库。 1.2 为什么选择Groovy正如官方的说法主要聚焦于java工程的构建，而至于为什么不直接采用java语言，因为由于java的局限性，做为构建语言表达力不够，不够强大。像Python,Groovy或Ruby可以做得更好。而我们选择Groovy,主要是它提供了对Java开发人员迄今为止最大的透明度。其基础语法与Java相同以及它的类型系统,其包结构和其他方面。 1.3 hello groovy1.3.1 Groovy开发环境根据官网的介绍 This tool makes installing Groovy on any Bash platform (Mac OSX, Linux, Cygwin, Solaris or FreeBSD) very easy.Simply open a new terminal and enter: $ curl -s get.sdkman.io | bash Follow the instructions on-screen to complete installation.Open a new terminal or type the command: $ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot; Then install the latest stable Groovy: $ sdk install groovy After installation is complete and you’ve made it your default version, test it with: $ groovy -version That’s all there is to it! 当执行完这行命令看到以下信息就代表Groovy开发环境搭建成功了 1.3.2开发第一个Groovy程序创建一个hello.groovy 文件，在里面输入一行代码 println &quot;hello groovy&quot; 执行命令 $ groovy hello 出结果如下图所示，怎么样是不是很简单呢 1.3.4 groovy基础语法介绍12345678910111213141516171819202122232425262728int i = 0 //groovy 支持java基础数据类型 也可以用// / * 来注释 语句可以不适用分号def b = false //也支持动态类型 定义变量可以不制定类型String s = 'hello'println "i=:$i ,b=:$b ,s=:$s" //输出双引号""中的美元符号＋名称代表一个变量 但是‘’单引号则不会 跟 java的String类型一样def map = ['key1':'value1','key2':'value2'] // groovy 容器类型 支持map list range/*** map 的调用方式是不是很奇怪？map 使用each来迭代 each其实是个方法* 完整的写法应该是* map.each(&#123;key,value-&gt;* println "key:$key value:$value" * &#125;) * 传入的大括号里面的东西是Groovy中非常重要的一个数据类型闭包 相当于java中的方法* -&gt;前面的闭包的参数，可指定类型，也可以不传参数 由于闭包太重要，待会儿会用一小节 * 来介绍这里读者先大概知道* 这么个东西，groovy中闭包可以不用括号**/map.each&#123;key,value-&gt; println "key:$key value:$value" &#125;println getString('test.groovy')def getString(params)&#123; //定义一个函数 函数默认返回最后一行代码执行结果 String s = "i am get string $params"&#125; 执行命令 $ groovy hello 看看输出结果 怎么样是不是对groovy的强大感到惊讶呢 使用一下命令就可以使groovy编译成java class 文件 groovyc -d classes hello.groovy 对class文件 jd-gui工具打开就可以看到反编译出来的java代码，如下图所示 1.3.5 闭包先来看一段代码，对着代码来一行一行解释 1234567//定义一个闭包def closure = &#123; params-&gt; // －&gt;前面代表参数 后面是函数体 String content = "i am closuer $params" println "$content $it" //最后一行 返回值 每个闭包都有一个默认的参数 it &#125; 是不是很神奇，有一点一定要牢记，调用闭包的时候是可以省略括号的例如android gradle中 project.task(&#39;hello&#39;) { doFirst { println project.greeting.message } } 在android gradle中很常见，到处都是这样的代码，其实如果写成下面这样的话就不奇怪了 project.task(&#39;hello&#39;) { doFirst ({ println project.greeting.message }) } 闭包中几个隐藏的重要的变量 it：默认的参数名，调用是如果没有传参数，it为null this : 跟Java一样，是定义闭包所在类的一个引用 始终指向该闭包所在的类 owner : 封闭闭包的对象 delegate :代理 缺省值是owner，但是可以改成任何值 1234567891011121314class Person&#123; def closure = &#123; println "hello $it" println this println owner println delegate &#125;&#125;def sc = 'hello delegate'def clo = new Person().closureclo()clo('closure')clo.delegate = scclo() 这段代码的执行结果如下 再来看一段代码深入理解下代理 123456789101112131415161718class Sex&#123; def desc = 'man'&#125;class Person&#123; Sex sex = new Sex() void changeSex(Closure clo)&#123; clo.delegate = sex clo.setResolveStrategy Closure.DELEGATE_FIRST clo() &#125;&#125;Person p = new Person()p.changeSex&#123; desc = 'women'&#125;println p.sex.desc 运行结果如下图所示 在这里是不是很茫然 ，因为p.changeSex并没有直接指明改变谁的desc属性，这是因为在我们把闭包的代理设置成了sex对象，而代理的默认ResolveStrategy属性值是OWNER_FIRST，闭包的delegate默认是指向闭包所在的类Person的，在这里我们把它的属性改成DELEGATE_FIRST，优先查找代理，理解闭包及其代理很重要，因为在android Gradle 这样的用法非常的多。具体大家可以去Groovy官网了解更多 2、Gradle 基础2.1 同样又是环境搭建根据官网的介绍 Get SDKMAN! $ curl -s https://get.sdkman.io | bash Open a new terminal and install Gradle $ sdk install gradle 3.2.1 最后执行如下命令 $ gradle -v 看到下图所示信息就代表gradle安装成功了 2.2 Gradle 基本对象介绍前些年做android项目的时候用的是eclipse，构建工具用的是ant，后来用android studio之后，最大的区别就是更加灵活，但是对build.gradle文件确实一脸萌比，每次碰到要配置什么东西，只有各种Google 百度，最后别人告诉你在build.gradle 文件中哪一个模块中那一行加上一句话就行。比如 defaultConfig { applicationId &quot;com.lingyi.test&quot; minSdkVersion 14 targetSdkVersion TARGET_SDK_VERSION.toInteger() versionCode VERSION_CODE.toInteger() versionName &quot;${VERSION_NAME}&quot; multiDexEnabled = true ndk { abiFilters &quot;armeabi-v7a&quot; } } multiDex是在app目录下的build.gradle 文件中的defuatconfig中添加一行multiDexEnabled ＝ true 虽然问题解决了，但是却很茫然，为什么是添加在这个位置，别的位置呢？添加了之后做了什么？做为一个有节操的程序员是绝对不允许这样的事情发生的。所以接下来我们去探一探gradle的神秘面纱。 2.2.1 gradle 基础介绍网上找了很多关于介绍gradle的，但是绝大多数都是介绍gradle应该怎么配置，却没有介绍为什么是这么配置。接下来我会对着开发文档和android 的build.gradle一步步分析。在分析之前的先了解gradle的一些基础知识，gradle的最基本重要的四个类 Settings 声明哪些project被包涵在这次构建中 可以使用 Settings.includ()来声明 Gradle 代表了一次调用 Project 每个工程一个build.gradle 每个build.gradle文件就是一个project 可以同这个她的实例访问他的所有属性 Task 是project的原子操作，如编译类或生成javadoc。 1) Settings 通过下图我们看看他最主要的一些属性 gradle属性返回当前构建的Gradle实例等，比较常用的属性有gradle plugins rootDir等，具体的每个属性代表什么含义，文档上面解释的很清楚。再来看看他有哪些方法 其中最熟息的有我们经常用的 apply 引入一个plugin或者project，传入的参数可以是，集合类型map 、也可以是一个closure（看闭包又出现了），include方法，传入的参数是集合list类型，分别是每个project的相对于根目录的相对路径， 例如我们的工程settings.gradle中 include &#39;:app&#39;, &#39;:biz&#39; 在我们的工程目录下就会引用 app 和 biz 两个moudle 其他的我就不一一介绍了 读者可以去官网 DSL refrence 详细了解 2.3 task 介绍 创建一个task每一个task都属于一个project，可以用taskContainer来创建或查找一个task实例， 2.3.1 例如使用 project的一个属性tasks 创建一个name 叫做 myTask的tasktasks.create(&#39;myTask&#39;){ println &quot;hello task&quot; } 2.3.2 例如使用 project创建一个 myTask taskproject.task(&#39;myTask&#39;){ println &quot;hello task&quot; } 也可以使用task 关键字创建一个task 2.3.3 例如使用 task 关键字创建一个 myTask tasktask myTask{ println &quot;hello task&quot; } 使用task 关键字还可以有很多种创建方法，如下 task myTask task myTask { configure closure } task myTask(type: SomeType) // task 还可以指定type 意思是从哪个task派生而来 task myTask(type: SomeType) { configure closure } 2.4 task 介绍 task actiontask由一系列的action组成，可以通过Task.doLast(Action)、Task.doFirst(Action)当然groovy的闭包也可以用来作为一个task action，Task.doLast(Closure)、Task.doFirst(Closure) ，当执行的时候closure被当成task的参数。 task myTask{ doLast({ //闭包可以去掉括号 println &quot;hello task&quot; }) } doLast当task执行的时候，作为最后一个action执行，同样doFirst被当作第一个，而doLast可以用 操作符 &lt;&lt; 代替，例如 task myTask &lt;&lt; { println &quot;hello task&quot; } 2.4 task介绍 task 之间的依赖关系，和顺序我们可以用dependsOn指定task之间的依赖关系，例如 task hello &lt;&lt; { println &quot;hello lingyi&quot; } task helloTask &lt;&lt; { println &quot;i am prints task print &quot; } hello.dependsOn &#39;helloTask&#39; hello 执行依赖helloTask,当我们敲下入下命令 $ gradle hello 输出结果如下,在hello 执行之前 执行了helloTask 还可以使用 Task.setDepends(java.lang.Iterable)给这个task设置一个依赖集合，也可以使用Task.shouldRunAfter(java.lang.Object[]),也可以Task.setShouldRunAfter(java.lang.Object[]) 2.4 task介绍 设置属性每个task系统都给了一些默认的属性和方法，当然我们也可以个他添加一些额外的属性例如 task hello &lt;&lt; { description = &#39;i am handsome boy&#39; println name + description } 执行命令 $ gradle hello 输出结果如下 当然可以添加一些自定义额外的属性 123456789101112131415ext.versionNames = "gradel 3.2.1"ext&#123; time= '2016 12 04'&#125;task hello &lt;&lt; &#123; println ext println "当前代理:"+delegate println "当前this:"+this println "当前owner:"+owner println versionNames println time&#125; 执行结果如下 看到这里是不是又有疑惑了？ext 是什么 为什么在task hello的闭包中能访问到，我们先来看看官网怎么介绍的 看了官网的解释，再加上前面介绍闭包的时候介绍的闭包的一个默认属性delegate，是不是感觉茅塞顿开？extensions的类型是 ExtensionContainer，它是一个ExtraPropertiesEatension容器 ,Gradle 会为每一个task添加一个extensions 动态属性 ，而task里面的闭包在创建的时候又会为它的delegate属性设置为 闭包所在的task 。 2.5 android app moudle下build.gradle首先我们先来看看一般这个文件怎么写,在看这个之前我们先了解android gradle 一个概念，代码块，官方说法是script block ,总共有下图那么多的script block 常见的有buildTypes 构建类型，就是我们常说的release,debug等 defualtconfig 版本名称，sdk版本，applicationId等 productFlavors 渠道信息,每个script block 都代理某个对象。 其实每个script block都是project的一个方法名叫做这个script block名字，参数为closure的方法，例如buildTypes BuildType 是一个构建配置的DSL对象 123456789101112131415161718192021222324252627282930313233343536373839android &#123; lintOptions &#123; //lintOptions scriptblock 静态代码检查配置代理到 LintOptions abortOnError false checkReleaseBuilds false &#125; buildToolsVersion "$&#123;BUILD_TOOLS_VERSION&#125;" compileSdkVersion COMPILE_SDK_VERSION.toInteger() defaultConfig &#123; //defuatConfig block script 所有渠道的共有配置信息 代理到 ProductFlavor对象 //还有很多属性可以去官网查看，写这个真得对着API来写 applicationId "com.mogujie.uni" minSdkVersion 14 targetSdkVersion TARGET_SDK_VERSION.toInteger() versionCode VERSION_CODE.toInteger() versionName "$&#123;VERSION_NAME&#125;" multiDexEnabled = true ndk &#123; abiFilters "armeabi-v7a" &#125; &#125; buildTypes &#123; // 构建类型 release &#123; project.archivesBaseName = "$&#123;PROJECT_DEBUG_ARCHIVE_NAME&#125;" signingConfig signingConfigs.myConfig buildConfigField "boolean", "LOG_DEBUG", "false" &#125; debug &#123; project.archivesBaseName = "$&#123;PROJECT_RELEASE_ARCHIVE_NAME&#125;" signingConfig signingConfigs.myConfig buildConfigField "boolean", "LOG_DEBUG", "true" &#125; &#125;&#125; 好了到了这里是不是发现原来百度、Google到的别人告诉你那么配置，现在是不是不仅知其然，而且知其所以然了呢？ 3、Gradle 进阶在介绍自定义task和plugin之前，先了解一下gradle的执行过程，gradle执行过程分为两个阶段1）评估阶段Evaluate 在这个阶段gradle主要是 全面扫描project task 给他们设置属性，理清它们之间的依赖关系，执行顺序等，2) 就是执行了 3.1、 自定义task3.1.1 第一种方式 直接在当前gradle文件中编写如下代码12345678910111213141516171819202122232425class OwnerTask extends DefaultTask&#123; //定义一个task 继承自 defaultTask def message = 'OwnerTask' //定一个属性 @TaskAction //为task 添加一个action action很简单 就是打印一句话 def ownerPrint()&#123; println "i am defuat message of $message" &#125;&#125;project.afterEvaluate&#123; //这个就是前面所提到的gradle的执行过程的第一步,在评估完成后调用的一个方法 //相当于java中设置一个listener 当评估完成立即回调这个方法 task owner0(type:OwnerTask) //定义一个task 从OwnerTask派生 task owner1(type:OwnerTask)&#123;//定义一个task 从OwnerTask派生 message = 'afterEvaluate'//但是为这个task 设置一下属性 &#125; /** * 找到所有的 build task 为他设置一个依赖 即在执行build之前必须先执行owner0 和owner1 */ project.getTasksByName("build",true).each &#123;task-&gt; task.dependsOn 'owner0' task.dependsOn 'owner1' &#125;&#125; 执行下面命令 $ gradle build 输出结果如下 输出结果完成符合预期，但是直接在build.gradle 文件中定义的task只能被当前的project使用 加入一个gradle 工程有几个project 不同的project都想使用，而且直接在build.gradle文件中定义太多的这样的task 影响阅读，和文件也太过庞大，接下来介绍第二种定义一个task的方法，在一个新的build.gradle中定义 3.1.2 第二种方式 在别的build.gradle 文件中创建第一步先在工程的根目录下新建一个文件夹名为buildSrc，如下图 然后在该目录下新建一个build.gradle文件，在文件中写下如下代码 123456apply plugin: 'groovy'dependencies&#123; compile gradleApi() compile localGroovy()&#125; 然后sync一发，等编译完成后系统会自动.gradle build src等目录，Gradle在执行时，会自动地查找该目录下所定义的Task类型，并首先编译该目录下的groovy代码以供build.gradle文件使用。然后再buildSrc/src/mian/groovy/com/lingyi/gradleTest文件下新建一个OwnerTask.groovy文件，再把刚才的代码copy 进去，如下： 12345678class OwnerTask extends DefaultTask&#123; //定义一个task 继承自 defaultTask def message = 'OwnerTask' //定一个属性 @TaskAction //为task 添加一个action action很简单 就是打印一句话 def ownerPrint()&#123; println "i am defuat message of $message" &#125;&#125; 然后再回到刚才最开始的build.gradle文件写下如下代码，效果是一样的 123456789101112project.afterEvaluate&#123; task owner0(type:com.lingyi.test.OwnerTask) task owner1(type:com.lingyi.test.OwnerTask)&#123; message = 'afterEvaluate' &#125; project.getTasksByName("build",true).each &#123;task-&gt; task.dependsOn 'owner0' task.dependsOn 'owner1' &#125;&#125; 因为这次我们是定义再不通的包目录下了 所以要引入包名，这和java是一样的道理 3.1.3 第三种方式 在新的工程中创建但是如果我们不想定义的task只是在自己的工程中使用呢？还想给别的gradle工程使用呢？接下来我们就来介绍第三种方法,我们在一个单独的工程中创建跟第二种一样的代码，然后只需在build.gradle中在加上如下几行代码即可 apply plugin &#39;maven&#39; //上传到远程maven jcenter仓库需要的插件 group = &#39;com.lingyi.hello&#39; //指定group名字 version = &#39;1.0-SNAPSHOT&#39; // 版本号 uploadArchives { repositories { mavenDeployer { repository(url: uri(&#39;../repo&#39;)) //这里就上传到本地 } } } 然后再执行如下命令 $ gradle upload 当build成功之后，我们会发现对应目录下多了如下的文件 在这里我在补充一下，刚为什么是执行 gradle upload命令就行了，因为gradle味了使用简单，执行 task 可以只写前面一部分，也支持驼峰法，即gradle uP也是可以的。 上传成功之后在需要引入的工程的根build.gradle文件的buildScript script block 中加入一下代码 repositories { maven { url uri(&#39;repo&#39;) //这里是本地的刚上传的目录 } jcenter() } classpath &#39;com.lingyi.hello:buildSrc:1.0-SNAPSHOT&#39; //在依赖的script block中加入这个依赖 com.lingyi.hello 就是我们刚指定的group名字，buildSrc是那个project的名字，因为刚刚我就直接在原来那个buildSrc目录下定义的那个task上传了，1.0-SNAPSHOT 是版本号。 然后再到需要应用的project的builde.gradle 文件中写入 123456789101112project.afterEvaluate&#123; task owner0(type:com.lingyi.test.OwnerTask) task owner1(type:com.lingyi.test.OwnerTask)&#123; message = 'afterEvaluate' &#125; project.getTasksByName("build",true).each &#123;task-&gt; task.dependsOn 'owner0' task.dependsOn 'owner1' &#125;&#125; 使用姿势跟前是一样的。 3.2 、自定义Pliugin其实自定义Plugin和自定义task 差不太多，都是三种方法，创建过程也基本一样，这里我主要介绍下第三种创建方式。跟自定义task一样，在buildSrc/src/main/groovy/com/lingyi/ownerplugin下创建一个名为HelloPlugin.groovy的文件，然后写下如下代码 12345678910111213141516171819202122232425import org.gradle.api.Pluginimport org.gradle.api.Projectclass HelloPlugin implements Plugin&lt;Project&gt;&#123; //实现Plugin接口 @Override void apply(Project project) &#123; //实现apply方法 /** * 跟task 一样拿到project的ext容器ExtensionContainer为plugin增加一个动态属性 * 前面在将task的时候也提到过每一个 ext对应的 script block其实就是方法名为例如author,参数 * 为Closure的一个方法 而这个closure又代理这个Author对象 */ project.extensions.create("author",Author) //拿到容器创建名为author的ext project.task('ownerPrint')&lt;&lt;&#123; //定义一个task 在他的doLast action里面打印代理对象author的值 println 'Author information:' println project.author.name println project.author.phone &#125; &#125;&#125;class Author&#123;//新建属性，和java不同 我们不需要手动为这个属性设置getter setter方法，gradle会自动为每个属性提供getter setter方法 ，为了减少开发成本 def name def phone&#125; 然后在build.gradle文件中加入和自定义task一样的代码，上传到maven本地库，如果想更这个plugin的名字也可以在这下面这个目录下增加一个你想要改成的名字的properties文件，例如： 在里面添加一行代码，如下所示： implementation-class=HelloPlugin 然后再在你需要应用这个插件的project的build.gradle 文件中加入如下代码 apply plugin &#39;com.lingyi.knif&#39; //com.lingyi.knif 就是插件名字 就是你刚改的那个名字，然后就可以在这个project中使用那个script block 了也可以使用那个定义的task，如下代码所示： 123456789author&#123; //script block 代理author对象 name = 'lingyi' phone = '18670088340'&#125;project.afterEvaluate&#123; project.getTasksByName('build',true).each &#123;task-&gt; task.dependsOn 'ownerPrint' //build task 依赖 ownerPrint我们自定义插件中的task &#125;&#125; 执行命令 $ gradle build 输出结果如下： 好了一切都跟预想的一样，到此我们的gradle的系列就全部讲完了哦。gradle从最初的各种配置的一脸萌比，相信一个有节操的程序猿都不会安于现状，肯定想去一探究竟的，所以本着这样精神陆陆续续花了一周的时间吧整个gradle都理了一边，主要原因还是最近一周的开发工作没那么忙。每天能按时下班做一下gralde的研究。好了看完了之后相信大家应该对gradle 也都有一个初步的了解了。下个系列再见了]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>